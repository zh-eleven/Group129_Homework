# project10

## ECDSA概述

椭圆曲线数字签名算法（ECDSA）是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟。ECDSA于1999年成为ANSI标准，并于2000年成为IEEE和NIST标准。它在1998年既已为ISO所接受，并且包含它的其他一些标准亦在ISO的考虑之中。与普通的离散对数问题（discrete logarithm problem DLP）和大数分解问题（integer factorization problem IFP）不同，椭圆曲线离散对数问题（elliptic curve discrete logarithm problem ECDLP）没有亚指数时间的解决方法。因此椭圆曲线密码的单位比特强度要高于其他公钥体制。

## 原理
ECDSA原理 ECDSA是ECC与DSA的结合，整个签名过程与DSA类似，所不一样的是签名中采取的算法为ECC，最后签名出来的值也是分为r,s。 签名过程如下： 1、选择一条椭圆曲线Ep(a,b)，和基点G； 2、选择私有密钥k（k<n，n为G的阶），利用基点G计算公开密钥K=kG； 3、产生一个随机整数r（r<n），计算点R=rG； 4、将原数据和点R的坐标值x,y作为参数，计算SHA1做为hash，即Hash=SHA1(原数据,x,y)； 5、计算s≡r - Hash * k (mod n) 6、r和s做为签名值，如果r和s其中一个为0，重新从第3步开始执行 验证过程如下： 1、接受方在收到消息(m)和签名值(r,s)后，进行以下运算 2、计算：sG+H(m)P=(x1,y1), r1≡ x1 mod p。 3、验证等式：r1 ≡ r mod p。 4、如果等式成立，接受签名，否则签名无效。

## ECDSA数字签名

### 签名过程如下：

   1、选择一条椭圆曲线Ep（a,b），和基点G；
   
   2、选择私有密钥k（k<n，n为G的阶），利用基点G计算公开密钥K=kG；
   
   3、产生一个随机整数r（r<n），计算点R=rG；
   
   4、将原数据和点R的坐标值x,y作为参数，计算SHA1做为hash，即Hash=SHA1(原数据,x,y)；
   
   5、计算s≡r - Hash * k (mod n)；
   
   6、r和s做为签名值，如果r和s其中一个为0，重新从第3步开始执行。
   
### 验证过程如下：

   1、接受方在收到消息(m)和签名值(r,s)后，进行以下运算；
   
   2、计算：sG+H(m)P=(x1,y1), r1≡ x1 mod p；
   
   3、验证等式：r1 ≡ r mod p；
   
   4、如果等式成立，接受签名，否则签名无效。
   
# 以太坊

以太坊（英文Ethereum）是一个开源的有智能合约功能的公共区块链平台，通过其专用加密货币以太币（Ether，简称“ETH”）提供去中心化的以太虚拟机（Ethereum Virtual Machine）来处理点对点合约。

以太坊的概念首次在2013至2014年间由程序员Vitalik Buterin受比特币启发后提出，大意为“下一代加密货币与去中心化应用平台”，在2014年通过ICO众筹开始得以发展。

截至2018年2月，以太币是市值第二高的加密货币，仅次于比特币。

# 以太坊中使用ECDSA签名并验证

ECDSA 签名由两个数字（整数）组成：r 和 s。以太坊还引入了额外的变量 v（恢复标识符）。签名可以表示成 {r, s, v}。

在创建签名时，你要先准备好一条待签署的消息，和用来签署该消息的私钥（dₐ）。简化后的签名流程如下：

1.对待签署消息进行哈希计算，得到哈希值（e）。

2.生成一个安全的随机数 k。

3.将 k 乘以椭圆曲线的常量 G，来计算椭圆曲线上的点（x₁, y₁）。

4.计算 r = x₁ mod n。如果 r 等于 0，请返回步骤 2 。

5.计算 s = k⁻¹(e + rdₐ) mod n。如果 s 等于 0，请返回步骤 2。

在以太坊上，通常使用 Keccak256("\x19Ethereum Signed Message:\n32" + Keccak256(message))来计算哈希值。这样可以确保该签名不能在以太坊之外使用。

由于 k 是随机值，我们每次得到的签名都不一样。如果 k 的随机程度不够高，或者随机值被泄漏，就有可能使用两个不同的签名计算出私钥【“fault attack”】。但是，如果你在 MyCrypto 内签署同一条消息，每次得到的输出值都相同，那么如何确保其安全性？这些确定性签名均采用 RFC 6979 标准。该标准描述了如何基于私钥和消息（或哈希值）来生成安全的 k 值。

{r, s, v} 签名可以组成一个长达 65 字节的序列：r 有 32 个字节，s 有 32 个字节，v 有一个字节。如果我们将该签名编码成一个十六进制的字符串，我们最后会得到一个 130 个字符长的字符串。大多数钱包和界面都会使用这个字符串。

为了验证消息，我们需要掌握原始消息、使用私钥签署消息的地址，以及 {r, s, v} 签名本身。版本号就是 MyCrypto 使用的某个版本号。旧版本的 MyCrypto 通常会加上消息的当前日期和时间，计算其哈希值，然后按照上述步骤签署该消息。后来又进行了更改，以符合 JSON-RPC 方法personal_sign 方法，因此需要指明版本号（“2”）。

简化后的公钥恢复流程如下：

1.计算消息的哈希值（e）。

2.计算椭圆曲线上的点 R = (x₁, y₁)，其中 x₁ 是 r（v = 27），或 r + n（v = 28）。

3.计算 u₁ = -zr⁻¹ mod n 和 u₂ = sr⁻¹ mod n。

4.计算点 Qₐ = (xₐ, yₐ) = u₁ × G + u₂ × R。

Qₐ 是地址用来签名的私钥所对应的公钥。我们可以通过公钥计算出一个地址，并检查该地址是否与已提供地址相符。如果相符，则签名有效。

恢复标识符（“v”）

v 是签名的最后一个字节，而且不是 27 (0x1b) 就是 28 (0x1c)。恢复标识符非常重要，因为我们使用的是椭圆曲线算法，仅凭r 和 s 可计算出曲线上的多个点，因此会恢复出两个不同的公钥（及其对应地址）。v 会告诉我们应该使用这些点中的哪一个。

在大多数实现中，v 在内部只是 0 或 1，而 27 是在签署比特币消息时加上的任意数。以太坊也接受了这一点。

从 EIP-155 开始，我们还使用链 ID 来计算 v 值。这可以防止跨链重放攻击：以太坊上签署的交易无法在以太坊经典上使用，反之亦然。目前，恢复标识符只用来签署交易而非消息。

ECDSA与区块链
=

1.比特币目前使用的 ECDSA 签名算法与建议的 Schnorr 签名算法，都属于椭圆曲线数字签名算法，它们使用的椭圆曲线都是 secp256k1。

2.ECDSA是基于 ECC 的数字签名算法，在比特币、以太坊等区块链网络中大量使用。每一笔区块链交易执行之前都必须进行权限校验，以确保该交易是由账户对应的私钥签发。256 位私钥的 ECDSA 签名可以达到 3072 位 RSA 签名的安全强度。


# 参考资料
[1]https://learnblockchain.cn/article/1613

[2]https://zhuanlan.zhihu.com/p/31671646

[3]https://blog.csdn.net/u013758702/article/details/121764374?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-121764374-blog-79871341.pc_relevant_default&spm=1001.2101.3001.4242.2&utm_relevant_index=4
